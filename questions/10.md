```go
import "fmt"

func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```

Данная программа выведет следующие значения:

```
1
1
```

# Пояснение:

1. Объявление переменных:
```go
var (
  a = 1
  p = &a
)
```
Здесь переменной `a` присваивается значение `1`, а `p` получает адрес переменной `a`. Таким образом, `p` указывает на `a`.

2. Первый вывод:
```go
fmt.Println(*p)
```
Поскольку `p` указывает на `a`, значение `*p` будет равно `1`, и это значение выводится.

3. Вызов функции `update`:
```go
update(p)
```
Функция `update` принимает указатель `p` в качестве аргумента. Внутри функции происходит следующее:
```go
b := 2
p = &b
```
Здесь создается новая локальная переменная `b` со значением `2`. Затем указатель `p` (локальная копия указателя, переданная в функцию) переназначается на адрес `b`. Однако это изменение затрагивает только локальную копию указателя `p` внутри функции `update` и не влияет на оригинальный указатель `p` в функции `main`.

4. Второй вывод:
```go
fmt.Println(*p)
```
После выхода из функции `update` указатель `p` в `main` все еще указывает на `a`. Значение `a` не изменилось и остается равным `1`. Поэтому выводится значение `1`.

Таким образом, программа выведет дважды `1` потому что изменения указателя внутри функции `update` не влияют на указатель в функции `main`.